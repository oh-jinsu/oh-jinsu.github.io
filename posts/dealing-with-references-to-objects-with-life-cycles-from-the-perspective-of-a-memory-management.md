---
date: 2022-10-27
keywords: [프로그래밍, 메모리 관리, 생명주기, 약한 참조, 강한 참조]
title: 메모리 관리 관점에서 생명주기를 가진 객체의 참조를 다루는 것
---

## 생명주기란?
일반적으로 생명주기는 어떤 객체가 생성되어서 소멸할 때까지의 기간을 말한다. 예를 들어 안드로이드에서 Activity라는 클래스는 다음과 같은 생명주기를 가지고 있다.

<figure class="thumbnail">
  <img src="/images/activity_lifecycle.png" alt="activity_lifecycle.png" />
  <cite>Activity의 생명주기. 이미지 출처: <a href="https://developer.android.com/guide/components/activities/activity-lifecycle" target="_blank" rel="noreferrer">android developer</a></cite>
</figure>

보다시피 생명주기는 자주 클래스의 형태를 띤 객체와 함께 등장한다. 개발자들도 클래스의 메서드를 활용하기 위해 위와 같은 식으로 이미 만들어진 생명주기를 찾아보게 되었을 것이다. 이를테면 Activity가 제공하는 `onStart` 메서드는 화면이 렌더링된 직후 코드를 실행시키고자 할 때 유용하다.

## 객체가 생성되고 소멸하기까지 지속한다는 의미

Activity가 생성되고 소멸하는 것처럼, 어떤 객체가 생성되고 소멸한다는 건 어떤 의미일까? 물론 그 의미는 구현하고 있는 대상에 따라 매우 달라진다. 당신이 안드로이드 앱을 개발하고 있다면 Activity의 생성은 가령 뷰모델을 초기화하고 뷰와 바인딩해야 한다는 의미일 것이다.

하지만 안드로이드 앱을 개발하는 입장이 아니라 안드로이드의 Activity를 개발하는 입장이라면 어떨까 상상해 보자. Activity라는 객체는 대체 언제 어디서 생성하고 언제 어디서 소멸시켜야 한다는 말일까? 게다가 객체는 대체 어떻게 그 사이의 시간동안 지속할 수 있는 걸까?

이건 아주 쓸모없는 질문들은 아니다. 누군가가 Activity를 개발해 주지 않았다면 바로 당신이 개발해야 했을 테니까.

### 어떻게 프로그램은 지속할까

내 경험을 말하자면, 나 역시 최근에 Rust와 같은 시스템 프로그래밍 언어를 다루면서 이러한 질문들에 봉착하게 되었다. 플래시로 처음 프로그래밍을 시작했고 유니티나 그밖에 안드로이드와 같이 친절한 객체지향적 프로그래밍 환경에 익숙한 나로서는 아래와 같은 단순한 프로그램이 신기할 따름이었다.

```rust
fn main() {
    println!("Hello World!");
}
```

주어진 프로그램은 우리가 항상 이야기하는 *클래스*나 *객체*가 아닌 단 하나의 *함수*로 이루어져 있다. 알고 보면 대표적인 객체지향 언어으로 취급받는 자바도 아래처럼 하나의 함수에서 모든 일을 시작하지 않던가.

```java
public class Program {
  public static void main(String[] args) {
    System.out.println("Hello World!");
  }
}
```

위 두 프로그램은 모두 실행하면 "Hello World!"라는 글자를 출력한 다음 곧바로 종료한다. 프로그램은 당연히 오랫동안 지속해야 한다고 생각하기 쉽다. 왜냐하면 사람들이 항상 이용하는 웹 브라우저나 모바일 애플리케이션 그리고 게임과 같은 프로그램은 종료시키기 전까지 지속하기 때문이다. 하지만 실제로는 그렇지 않다.

프로그램은 `main` 함수의 중괄호 안에 줄줄이 적힌 모든 코드를 한 줄씩 읽고 실행하고 나면 스스로를 종료한다. 물론 프로그램은 아주 잠깐 지속할 것이다. 왜냐하면 프로그램이 코드를 읽고 실행하는 데에는 시간이 들기 때문이다. 하지만 이 시간이 아주 찰나인 탓에 우리 눈에는 프로그램이 즉시 종료하는 것처럼 보인다.

그렇다면 프로그램이 충분히 긴 시간 동안 지속하도록 만드는 방법은 무엇일까? 답은 간단하다. 시간을 소요하는 작업을 끊임없이 반복하도록 만들면 된다. 이를테면 다음의 코드처럼.

```rust
fn main() {
    loop {
        println!("Hello World!");
    }
}
```

주어진 코드는 `println`이라는 시간이 드는 작업을 무한히 명령해 놓은 것과 같으므로 프로그램은 영원히 지속한다.

그렇지만 짚어 두자면 이렇게 지속하는 데에는 분명한 이유가 있어야 할 것이다. 그 이유는 단순히 프로그램이라는 사실만으로는 충족되지 않는다. 예를 들어 웹 애플리케이션 서버는 왜 지속해야 할까? 그건 이용자들이 언제든지 원하는 내용을 받아 갈 수 있어야 하기 때문이다.

### 생성과 소멸

우리가 프로그램 안에서 무언가를 생성하고 소멸시킬 수 있다면 그건 무엇일까? 그건 변수다. 객체 역시 변수들의 묶음을 파악하기 쉽도록 이름 지은 것에 지나지 않는다. 나아가 우리는 무언가를 "생성"하고 "소멸"시킨다고 이야기하지만, 이때 실제로 일어나는 건 어떤 값을 위해 메모리를 할당하고 해제하는 일일 뿐이다. 즉 모든 건 메모리를 조작하는 일에 편리한 이름을 부여한 행위로 간주할 수 있다.

```rust 
fn main() {
    let a = 1;
}
```

프로그램은 변수 `a`를 이용하기 위해 메모리를 할당할 것이다. 그리고 `a`를 위한 메모리는 프로그램을 종료하기 전에 해제해야 한다. 어떤 언어들은 메모리 해제를 일일이 개발자의 손에 맡기는가 하면, 또 다른 언어들은 자동으로 처리해 주기도 한다.

## 객체가 지속하는 공간

개중에서 Rust는 소유권(Ownership)이라는 특별한 규칙을 도입해 메모리 관리를 아주 직관적으로 만들어 주었다. 다음과 같이 생각하면 쉽다. 

> 변수를 위해 할당한 메모리는 변수를 소유한 스코프(중괄호)가 끝날 때 해제된다.

앞선 예를 그대로 가져오자면 변수 `a`의 메모리는 변수 `a`를 소유한 `main` 함수가 끝날 때 해제되는 것이다. 무언가가 생성되고 소멸하는 일이 흔히 알고 있는 클래스 형태의 객체를 중심으로 작동하지 않는다는 사실에 주목하자. 생성과 소멸은 오히려 함수를 중심으로 작동한다.

특히 Rust에서는 이러한 작동을 추적하기가 매우 용이하다. 물론 이러한 성질은 다른 언어들에서도 적용되는 것이다. 그렇지만 다른 언어는 본질적으로 이러한 작동을 신경쓰지 않아도 되게끔 설계되었기 때문에 보지 못할 뿐이다. 

Rust에서 객체를 만들어 보자.

```rust
struct Person {
  name: String,
  age: i32,
}

fn main() {
  let name = String::from("오진수");

  let age = 23;

  {
    let person = Person {
      name,
      age,
    }
  }
}
```

소유권 규칙에 따라 변수 `name`과 `age`의 메모리를 해제할 책임은 모두 `Person`에게 옮겨간다. 즉 `name`과 `age`의 메모리는 `main` 함수의 스코프가 끝날 때 해제되는 것이 아니라 변수 `person`을 감싼 스코프의 끝에서 `person`과 함께 해제되는 것이다.

이처럼 객체의 생명주기가 언제나 어떤 스코프 내부에서 결정된다는 사실을 인지하는 것이 중요하다. 다음은 생성되어서 약 10초 동안 지속한 다음 소멸하는 객체의 예시다.

```rust
{
  let person = Person { name, age }

  for _ in 0..10 {
    std::thread::sleep(std::time::Duration::from_millis(1000));
  }
}
```

싱글 스레드 환경에서 이러한 예는 그다지 감흥이 없을지도 모른다.

```rust
fn main() {
  {
    let person = Person { name: String::from("진수"), age: 23 };

    let person = std::sync::Arc::new(person);

    let weak_person = std::sync::Arc::downgrade(&person);

    std::thread::spawn(move || loop {
      match weak_person.upgrade() {
          Some(_) => println!("It is still alive!"),
          None => println!("It has been destroyed."),
      }

      std::thread::sleep(std::time::Duration::from_millis(100));
    });
    
    for _ in 0..100000000 {}
  }

  loop {}
}
```

이 프로그램은 메인 스레드 이외에도 하나의 스레드를 더 사용하고 있다. 추가로 사용하는 스레드에서는 스스로가 소유권을 가지지 않은 객체 `person`에 대한 소멸 여부를 이른바 약한 참조를 이용해 100ms마다 한 번씩 확인한다. 반면 메인 스레드에서 `person`에 대한 소유권을 가진 스코프는 아무 의미 없는 반복문을 1억 번 돌다가 스코프를 끝낸다. 이 효과로 `person` 객체는 반복문을 1억번 통과하는 시간 동안 소멸하지 않을 것이다.

2020 맥북 13 프로 M1에서 위의 프로그램을 수행한 결과 "It is still alive!"라는 메시지는 11번 찍혔고 그 다음부터는 "It has been destroyed."라는 메시지가 계속되었다. `person` 객체는 스코프 내부에서 약 1초 동안 지속했던 것이다.

## 약한 참조와 강한 참조를 사용하는 경우

물론 추가로 생성한 스레드에 약한 참조를 넘기지 않고 강한 참조를 넘겼다면 이야기는 달라진다. 그렇다면 사실 소멸 여부를 확인한 필요도 없어진다. 왜냐하면 새로운 스레드도 객체에 대한 소유권을 가지게 되기 때문이다. 소유권을 가진다는 것은 다르게 말해서 스스로의 스코프 내부에서는 객체가 소멸하지 않는다는 의미와 같다.

가비지컬렉터를 내장한 언어들은 변수가 다른 스코프로 이동할 때마다 이 강한 참조를 넘기는데, 이것이 바로 우리가 메모리 누수라고 부르는 현상의 원인으로 작용한다. 메모리 누수란 별다른 것이 아니다. 해제되어야 할 메모리가 해제되지 않는 것이다.

실용적인 예를 들어 보자.

```go
func main() {
  l, err := net.Listen("tcp", ":3000")

  if err != nil {
    return
  }

  defer l.close()

  for {
    conn, err := l.Accpet()

    if err != nil {
      return
    }

    go func(conn net.Conn) {
      defer conn.close()

      buf := make([]byte, 1024)

      for {
        n, err := conn.Read(buf)

        if err != nil {
          return
        }

        if n > 0 {
          log.Println(string(buf[:n])) 
        }
      }
    }(conn)
  }
}
```

Golang으로 간단하게 구현한 TCP 소켓 서버다. `defer` 키워드에 주목하자. `defer`는 스코프가 끝날 때 실행을 예약하는 키워드다. 주어진 코드에서는 모종의 에러가 발생한 경우 `return`을 통해 반복문을 탈출하게 되면서 스코프는 끝난다. 특히 위와 같은 맥락에서 반복문들은 `TcpListener`나 `Conn`이라는 객체가 존재하는 이유와도 같은데, 반복문이 종료됨에 따라 더 이상 필요가 없어졌으므로 `defer` 키워드의 도움을 받아 객체와 연관된 메모리를 해제하는 것이다.

하지만 강한 참조를 다음과 같이 사용하는 경우에는 객체를 일일이 소멸시키는 방법말고는 다른 도리가 없다. (그리고 특히 소멸에 관한 코드를 객체 내부에서 처리하면 확장성이 심각하게 저하된다.)

```go
func main() {
  sockets = make(map[string]net.Conn)

  l, err := net.Listen("tcp", ":3000")

  if err != nil {
    return
  }

  defer l.close()

  for {
    conn, err := l.Accpet()

    sockets[conn.RemoteAddr().ToString()] = conn;

    if err != nil {
      return
    }

    go func() {
      for ...
    }
  }
}
```

`net.Conn`을 모아두는 해쉬맵은 특정한 목적에 따라 편리하게 사용할 수 있다. 하지만 Golang과 같이 가비지컬렉터를 가지고 있는 언어에서는 해쉬맵에 강한 참조가 저장된다. 고루틴의 반복문이 끝나면서 `net.Conn`이 더 이상 쓸모 없게 되어도 해쉬맵 안에는 `net.Conn`이 마치 여전히 살아 있는 것처럼 저장되어 있다. 그래서 이를 섬세하게 다루지 않으면 메모리가 점점 쓸데 없는 자원으로 채워지거나 치명적인 런타임 오류와 맞닥뜨리게 된다.

내 생각에, 객체는 필요한 시간 만큼만 존재하며 또 그래야만 한다. 마치 `net.Conn`이 이용자와 연결을 유지하기 위해 반복문을 수행하는 시간 만큼만 존재하며 또 그래야만 하는 것처럼 말이다.

객체가 생성되어서 반복문과 같은 일정한 연산을 수행하고 소멸되기까지 생명주기를 담고 있는 어떤 함수 혹은 어떤 스코프. 어떤 객체의 시간을 관리하는 함수 혹은 스코프에게는 Rust처럼 말해서 소유권이 있다. 이러한 소유권을 분명하게 인지하면 다른 함수 혹은 스코프로 객체를 넘겨 주어야 할 필요가 있을 때 어떤 방식의 참조로 넘겨야 할지 판단할 수 있다.

- 다른 함수 혹은 스코프가 객체의 생명주기에 종속적이라면 약한 참조로 넘겨 주어야 한다.
- 다른 함수 혹은 스코프도 객체의 생명주기를 함께 관리해야 한다면 강한 참조를 나눠 가져야 한다.